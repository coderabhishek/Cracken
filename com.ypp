%{
#include<iostream>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<string.h>
#include<stdio.h>
#include<stack>
#include<stdlib.h>
#include<memory>

#include "util.cpp"

using namespace std;

//For debug
bool ch = true;
#define YYDEBUG 1
extern char *yytext;
extern int yylineno;
void yyerror(string);
int yylex();
void yywrap();
#define max_tab_size 1000
int size[max_tab_size];

bool func_bool = false;
%}

%union {char str[50]; struct code_segment* cs; struct param_list* pl;}
%start program;
%token COL;
%token OP_PARENS;
%token CL_PARENS;
%token OP_BR;
%token CL_BR;
%token OP_SQBR;
%token CL_SQBR;
%token IF;
%token ELSE;
%token ELSEIF;
%token WHILE;
%token EQ;
%token COMMA;
%token STAR;
%token DIVIDE;
%token PLUS;
%token MINUS;
%token STRUCT;
%token RETURN;
%token <str> TYPE;
%token <str> COMPARATOR;
%token <str> IDENTIFIER;
%token <str> INT_VAL;
%token <str> CONST_STR;
%token <str> REAL_VAL; 
%type <str> constant;
%type <cs> expr; 
%type <cs> expr_l;
%type <cs> assignment;
%type <cs> lines;
%type <cs> line;
%type <cs> if_block;
%type <cs> loop_block;
%type <cs> var_list;
%type <cs> decl;
%type <str> place_holder;
%type <cs> expr_ll;
%type <cs> IDENTIFIER_LIST;
%type < pl > param_list 
%type <str> param;
%type <cs> function;
%type <cs> return_stmt;
%%

program : lines program {
	cout<<"IC--->\n\n"<<$1->ic<<"\n";       
}| function program {
	cout<<"IC--->\n\n"<<$1->ic<<"\n";       
}| lines{
	cout<<"IC--->\n\n"<<$1->ic<<"\n";       
}	| function {
	cout<<"IC--->\n\n"<<$1->ic<<"\n";       
}	


function : IDENTIFIER IDENTIFIER OP_BR param_list CL_BR OP_PARENS lines CL_PARENS{
	if(types.find($1) == types.end())
		yyerror("Unknown type " + string($1) + ". ");
	if($7->type != $1)
		yyerror("Wrong return type!!");		
	func temp_f = func();
	temp_f.name = string($2);
	temp_f.r_type = string($1);
	temp_f.para_type_list = $4->v; 
	funcs.push_back(temp_f);
	$$ = create();
	$$->type = $1;
	$$->ic = "begfunc " + string($2) + to_string(size_of_param_frame(temp_f.para_type_list)) + ";\n";
	$$->ic += $7->ic;
	$$->ic += "func end;\n";	
	cur_scope++;
	func_bool = false;
}

param_list : param param_list{
	$$ = $2;
	$$->v.push_back(string($1));	
} | param {
	vector<string> v = {string($1)};
	$$ = new param_list();
	$$->v = v;
	
}

param : IDENTIFIER IDENTIFIER {
      	if(!func_bool)
	{
		cur_scope--;
		func_bool = true;
	}
	strcpy($$, $1);     
	sym_table.set($2, $1); 
}



line : decl COL{
	$$ = $1;
} | expr COL{
	$$ = $1;
} | if_block {
	$$ = $1;
} | loop_block {
	$$ = $1;
} | struct_def{
	cout<<"STruct Matched thats bad!!\n";
	$$ = NULL;
} | assignment {
	$$ = $1;
} | return_stmt {
	$$ = $1;
}

return_stmt : RETURN IDENTIFIER COL {
	$$ = create();
	$$->type = sym_table.get($2);
	$$->ic = "return " + string($2) + ";\n";
}

assignment : IDENTIFIER EQ expr COL {
	if(!sym_table.find($1))
		yyerror("No var named " + string($1) + " defined!!");
	if($3->type != sym_table.get($1))
		yyerror("Type mismatch!! Can't assign " + $3->type + " to " + sym_table.get($1) + ".");
	$$ = create();	
	$$->type = "void";
	$$->ic = $3->ic;
	$$->ic += string($1) + " = _t0;\n"; 
}
struct_def : STRUCT IDENTIFIER OP_PARENS var_list CL_PARENS COL {
	for(auto el: struct_sub_type){
		cout<<el.first<<"   "<<el.second<<endl;
	}	
	cout<<"\n\n\n\n";
	for(auto el: types){
		cout<<el.first<<"   "<<el.second<<endl;
	}
}

var_list : IDENTIFIER IDENTIFIER COL {
	if(types.find($1) == types.end())
		yyerror("Undefined type.");
	else {
		struct_sub_type[string($<str>-1) + "." + string($2)] = $1; 
	}
	types[$<str>-1] += types[$1];
}
| IDENTIFIER IDENTIFIER COL var_list {
	if(types.find($1) == types.end())
		yyerror("Undefined type.");
	else {
		struct_sub_type[string($<str>-1) + "." + string($2)] = $1; 
	}
	types[$<str>-1] += types[$1];
}

if_block : IF OP_BR expr COMPARATOR expr  CL_BR if_scope_prod OP_PARENS lines CL_PARENS {
	$$ = create();
	$$->type = $9->type;
	string l1 = get_label();
	$$->ic = $3->ic + "\n";
	$$->ic += "_t1 = _t0;\n";
	$$->ic += $5->ic;	
	$$->ic += "_t0 = _t1 " + string($4) + " _t0;\n"; 
	$$->ic += "ifz _t0 goto " + l1 + ";\n";
	$$->ic += $9->ic + "\n";
	$$->ic += l1  + ":\n";  
	cur_scope++;
} 

if_scope_prod : /* empty */ {
	cur_scope--;	     
}

loop_block : WHILE OP_BR expr COMPARATOR expr CL_BR while_scope_prod OP_PARENS lines CL_PARENS {
	$$ = create();
	$$->type = $9->type;
	string l1 = get_label(), l2 = get_label();

	$$->ic = l2 + ":\n";
	$$->ic += $3->ic + "\n";
	$$->ic += "_t1 = _t0;\n";
	$$->ic += $5->ic;	
	$$->ic += "_t0 = _t1 " + string($4) + " _t0;\n"; 	
	$$->ic += "ifz _t0 goto " + l1 + ";\n";
	$$->ic += $9->ic + "\n";
	$$->ic += "goto " + l2 + ";\n";
	$$->ic += l1  + ":\n";  
	cur_scope++;
}

while_scope_prod : /* empty */ {
	cur_scope--;		 
}

lines : line lines{
	$$ = create();
	if($1->type == "void" and $2->type!="void")
		$$->type = $2->type;
	else if($2->type == "void" and $1->type!="void")
		$$->type = $1->type;
	else if($2->type != $1->type)
		yyerror("Return type mismatch!! " + string($1->type) + " and " + string($2->type) + ".");	
	else $$->type = $1->type;
	    
	$$->ic = $1->ic +"\n" + $2->ic; 
} | line {
	$$ = create();
	$$->type = $1->type;
	$$->ic = $1->ic;
}

decl : IDENTIFIER IDENTIFIER_LIST {
 if(types.find($1) == types.end())
		yyerror("Undefined type.");   
	$$ = $2;
}


/*Not done */
IDENTIFIER_LIST : IDENTIFIER EQ expr COMMA IDENTIFIER_LIST {
	if($3->type != $<str>0)
		yyerror("Type mismatched " + $3->type + "   " + $<str>0);		
	sym_table.set($1, $<str>0);
	$$ = create();
	$$->type = $<str>0;
	$$->ic = $3->ic;
	$$->ic += string($1) + " = _t0;\n";
	$$->ic += $5->ic + "\n"; 
}| IDENTIFIER COMMA IDENTIFIER_LIST{
	sym_table.set($1, $<str>0);
	$$ = create();
	$$->type = $<str>0;
	$$->ic = string($1) +  " = 0;\n";
	$$->ic += $3->ic + "\n";	
}  | IDENTIFIER EQ expr{
	if($3->type != $<str>0)
		yyerror("Type mismatched " + $3->type + "   " + $<str>0);		
	sym_table.set($1, $<str>0);
	$$ = create();
	$$->type = $<str>0;
	$$->ic = $3->ic;
	$$->ic += string($1) + " = _t0;\n";
} | IDENTIFIER { sym_table.set($1, $<str>0);
	$$ = create();
	$$->type = $<str>0;
	$$->ic = string($1) + " = 0;\n";
} 

place_holder : IDENTIFIER {
	strcpy($$, $1);
}| constant{
	strcpy($$, $1);
} 
/*   --- ND --- */

expr: expr PLUS expr_l {
	$$ = create();
	if($1->type != $3->type)
		yyerror("Type Mismatch!!");
	$$->type = $1->type;
	string temp = $1->ic + "\n";
	temp += "_t1 = _t0;\n";
	temp += $3->ic + "\n";
	temp += "_t0 = _t1 + _t0;\n";
	$$->ic = temp;
}| expr MINUS expr_l {
	$$ = create();
	if($1->type != $3->type)
		yyerror("Type Mismatch!!");
	$$->type = $1->type;
	string temp = $1->ic + "\n";
	temp += "_t1 = _t0;\n";
	temp += $3->ic + "\n";
	temp += "_t0 = _t1 - _t0;\n";
	$$->ic = temp;
}| expr_l {
	$$ = create();
	$$->type = $1->type;
	string temp = $1->ic + "\n";
	$$->ic = temp;
}| OP_BR expr CL_BR {
	$$ = create();
	$$->type = $2->type;
	string temp = $2->ic + "\n";
	$$->ic = temp;
}

expr_l : expr_l STAR expr_ll {
	$$ = create();
	if($1->type != $3->type)
		yyerror("Type Mismatch!!");
	$$->type = $1->type;
	string temp = $1->ic + "\n";
	temp += "_t1 = _t0;\n";
	temp += $3->ic + "\n";
	temp += "_t0 = _t1 * _t0;\n";
	$$->ic = temp;
}| expr_l DIVIDE expr_ll {
	$$ = create();
	if($1->type != $3->type)
		yyerror("Type Mismatch!!");
	$$->type = $1->type;
	string temp = $1->ic + "\n";
	temp += "_t1 = _t0;\n";
	temp += $3->ic + "\n";
	temp += "_t0 = _t1 / _t0;\n";
	$$->ic = temp;
}| expr_ll  {
	$$ = $1;
}

expr_ll : place_holder {
	$$ = create();
	$$->type = find_type($1);
	$$->ic = "_t0 = " + string($1) + ";\n";
}  




/*| OP_PARENS expr CL_PARENS {
}| expr PLUS sub_expr {
}| expr MINUS sub_expr | IDENTIFIER EQ expr | expr COMMA expr  */

/*sub_expr : place_holder STAR place_holder | place_holder DIVIDE place_holder | expr*/ 

constant : REAL_VAL {
strcpy($$, $1);		 
}| INT_VAL {
strcpy($$, $1);		 
}| CONST_STR {
strcpy($$, $1);		 
}
%%
int main(){
	global_addr = 0;	
	types_init();
	return yyparse();
}
void yywrap(void) {
	return;
}

void yyerror(string s){
	cout<<"Error near line "<<yylineno<<" Token->  "<<yytext<<"\n\n"<<s;
}
